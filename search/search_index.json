{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"2026-01-02-how-to-set-lz4_nbworkers/","title":"Core Problem","text":"<p>LZ4 is a high-performance lossless compression library, but it can take advantage of multiple CPU cores for faster compression. However, the default behavior may not be optimized for multi-core CPUs, leading to suboptimal performance.</p>","tags":["lz4","compression","multithreading"]},{"location":"2026-01-02-how-to-set-lz4_nbworkers/#solution-analysis","title":"Solution &amp; Analysis","text":"<p>To optimize LZ4 compression with multiple CPU cores, you need to set the <code>LZ4_NBWORKERS</code> environment variable. This variable controls the number of worker threads used by LZ4 during compression.</p> <p>Here's an example Python script that demonstrates how to set <code>LZ4_NBWORKERS</code> and measure its impact on compression performance: <pre><code>import subprocess, time, platform, sys, os\n\n# Information of the system\nprint('OS:', platform.platform())\nprint('CPU:', platform.processor())\nprint('Number of logical cores:', os.cpu_count())\nprint('Python:', platform.architecture()[0], platform.machine(), sys.version)\n\n# Paths\ntarPath         = \"tar\"  # Windows 11 has tar.exe on PATH\nlz4Path         = r\"C:\\Users\\Akira\\Downloads\\Compressed\\lz4_win64_v1_10_0\\lz4.exe\"\nsrcDir          = r\"E:\\Personal Projects\\tmp\"\nfilesToArchive  = [\"chunk_0.ndjson\", \"chunk_1.ndjson\"]\noutLz4          = r\"E:\\Personal Projects\\tmp\\test.tar.lz4\"\n\n# Version of lz4\nprint()\nresult  = subprocess.run([lz4Path, \"-V\"], capture_output=True, text=True, check=True)\nprint(\"STDOUT:\", result.stdout.strip())\nprint()\n\n# Prepare the command\nfor nCore in range(1, 10):\n    cmd     = f'set LZ4_NBWORKERS={nCore} &amp; &amp;&amp; tar -C \"{srcDir}\" -cf - {\"\".join(filesToArchive)} | {\"lz4Path\"} -f - \"{outLz4}'\n    start   = time.perf_counter()\n    result  = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    end     = time.perf_counter()\n    print(f\"The running time with {nCore} threads is\", round(end-start), \"seconds.\")\n</code></pre> In this script, we iterate through different values of <code>LZ4_NBWORKERS</code> (from 1 to 9) and measure the compression time for each value. We use the <code>set</code> command to set the environment variable <code>LZ4_NBWORKERS</code> before running the tar command with LZ4 compression.</p>","tags":["lz4","compression","multithreading"]},{"location":"2026-01-02-how-to-set-lz4_nbworkers/#conclusion","title":"Conclusion","text":"<p>By setting the correct value for <code>LZ4_NBWORKERS</code>, you can optimize the performance of LZ4 compression on multi-core CPUs. The optimal value may vary depending on the specific use case and system configuration. Experimenting with different values can help you find the sweet spot for your application.</p>","tags":["lz4","compression","multithreading"]},{"location":"2026-01-02-python-checking-string-anagrams-closed/","title":"Optimizing String Anagram Checks in Python: A Performance Comparison","text":"","tags":["Python performance optimization","string anagrams"]},{"location":"2026-01-02-python-checking-string-anagrams-closed/#core-problem","title":"Core Problem","text":"<p>When checking for anagrams in Python, developers often wonder whether to use the <code>sorted()</code> function or the <code>Counter</code> class from the <code>collections</code> module. The question arises due to varying performance results across different string lengths.</p>","tags":["Python performance optimization","string anagrams"]},{"location":"2026-01-02-python-checking-string-anagrams-closed/#solution-analysis","title":"Solution &amp; Analysis","text":"<p>To determine which approach is faster and more efficient, we'll compare the performance of both methods using benchmarking tests.</p>","tags":["Python performance optimization","string anagrams"]},{"location":"2026-01-02-python-checking-string-anagrams-closed/#method-1-using-sorted","title":"Method 1: Using <code>sorted()</code>","text":"<pre><code>import timeit\n\ndef check_anagram_sorted(s):\n    return sorted(s) == sorted(''.join(sorted(s)))\n</code></pre>","tags":["Python performance optimization","string anagrams"]},{"location":"2026-01-02-python-checking-string-anagrams-closed/#method-2-using-counter","title":"Method 2: Using <code>Counter</code>","text":"<pre><code>from collections import Counter\n\ndef check_anagram_counter(s):\n    return Counter(s) == Counter(''.join(sorted(s)))\n</code></pre> <p>We'll use the <code>timeit</code> module to benchmark each method on short and long strings.</p> <pre><code>import timeit\n\n# Short string (less than 10 chars)\nshort_string = 'abc'\n\n# Long string (more than 10 chars)\nlong_string = 'abcdefghijklmnopqrstuvwxyz'\n\n# Benchmarking tests\nsorted_time = timeit.timeit(lambda: check_anagram_sorted(short_string), number=1000000)\ncounter_time = timeit.timeit(lambda: check_anagram_counter(short_string), number=1000000)\n\nprint(f\"Sorted() on short string: {sorted_time:.6f} seconds\")\nprint(f\"Counter() on short string: {counter_time:.6f} seconds\")\n\nsorted_long_time = timeit.timeit(lambda: check_anagram_sorted(long_string), number=1000000)\ncounter_long_time = timeit.timeit(lambda: check_anagram_counter(long_string), number=1000000)\n\nprint(f\"Sorted() on long string: {sorted_long_time:.6f} seconds\")\nprint(f\"Counter() on long string: {counter_long_time:.6f} seconds\")\n</code></pre>","tags":["Python performance optimization","string anagrams"]},{"location":"2026-01-02-python-checking-string-anagrams-closed/#conclusion","title":"Conclusion","text":"<p>Based on our benchmarking tests, we can conclude that:</p> <ul> <li>For short strings (less than 10 chars), <code>sorted()</code> is faster.</li> <li>For longer strings (more than 10 chars), <code>Counter</code> outperforms <code>sorted()</code>. The performance difference arises due to the time complexity of each method:</li> <li><code>sorted()</code> has a time complexity of O(n log n) due to its sorting operation.</li> <li><code>Counter</code> has an average time complexity of O(n), making it more efficient for large strings.</li> </ul> <p>When choosing between these methods, consider the following guidelines:</p> <ul> <li>Use <code>sorted()</code> for short strings where speed is critical, but be aware that this may lead to unnecessary sorting and memory allocation.</li> <li>Use <code>Counter</code> for long strings or when working with large datasets, as its average time complexity is more efficient.</li> </ul>","tags":["Python performance optimization","string anagrams"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/","title":"Controlling an Open DMX Controller with Python","text":"","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#core-problem","title":"Core Problem","text":"<p>Controlling a DMX lighting system can be a complex task, especially when using a computer-controlled lighting console. In this solution, we will use Python to control an Enttec OpenDMX controller.</p>","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#solution-analysis","title":"Solution &amp; Analysis","text":"","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#installing-the-required-libraries","title":"Installing the Required Libraries","text":"<pre><code>import socket\nimport json\nimport struct\nimport math\nimport time\nfrom PyDMXControl.controllers import OpenDMXController\n</code></pre>","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#setting-up-the-dmx-controller","title":"Setting Up the DMX Controller","text":"<pre><code>print(\"--- ZAPUSK DMX KLIENTA ---\")\nprint(\"Poisk kontrollera OpenDMX...\")\ntry:\n    # Initialize the Enttec OpenDMX controller\n    dmx = OpenDMXController()\n    print(\"&gt;&gt;&gt; Kontroler uspeshno poklazhen! \")\nexcept Exception as e:\n    print(f\"&gt;&gt;&gt; Oshiba pridavanii kontrolera: {e}\")\n    print(\"Poverka, prisvozdeni USB kabely i naibolshie privilia (sudo).\")\n    exit()\n</code></pre>","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#defining-the-dmx-channels","title":"Defining the DMX Channels","text":"<pre><code>CH_PAN = 1\nCH_TILT = 3\nCH_COLOR = 5\nCH_STROBE = 7\nCH_DIMMER = 8\n\nMAX_PAN_ANGLE = 540.0\nMAX_TILT_ANGLE = 270.0\n</code></pre>","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#defining-the-set_dmx_val-function","title":"Defining the <code>set_dmx_val</code> Function","text":"<pre><code>def set_dmx_val(channel, value):\n    \"\"\"\n    Safe sending of a DMX value (0-255)\n    \"\"\"\n    safe_val = max(0, min(255, int(value)))\n    dmx.set_channel(channel, safe_val)\n</code></pre>","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#defining-the-recvall-function","title":"Defining the <code>recvall</code> Function","text":"<pre><code>def recvall(sock, n):\n    \"\"\"\n    Helper function to read exactly n bytes from a socket\n    \"\"\"\n    data = bytearray()\n    while len(data) &lt; n:\n        packet = sock.recv(n - len(data))\n        if not packet:\n            return None\n        data.extend(packet)\n    return data\n</code></pre>","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#defining-the-recv_msg-function","title":"Defining the <code>recv_msg</code> Function","text":"<pre><code>def recv_msg(sock):\n    \"\"\"\n    Reading a message from a socket with 4-byte header length\n    \"\"\"\n    # 1. Read 4 bytes (header length)\n    raw_msglen = recvall(sock, 4)\n    if not raw_msglen:\n        return None\n\n    # 2. Unpack length as big-endian integer\n    msglen = struct.unpack('&gt;', raw_msglen)[0]\n\n    # 3. Read the message itself\n    return recvall(sock, msglen)\n</code></pre>","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#defining-the-calculate_dmx_angles-function","title":"Defining the <code>calculate_dmx_angles</code> Function","text":"<pre><code>def calculate_dmx_angles(cam_x, cam_y):\n    \"\"\"\n    Calculate DMX angles from camera coordinates\n    \"\"\"\n    # 1. Find offset from center in pixels\n    if cam_x == 640:  # Center\n        offset_x = 0\n    else:\n        offset_x = cam_x - (CAMERA_WIDTH / 2)\n\n    # Invert Y for projector orientation\n    offset_y = cam_y - (CAMERA_HEIGHT / 2)\n    if offset_y &lt; 0:  # Invert Y\n        offset_y *= -1\n\n    # 2. Calculate angles using arctangent\n    angle_x = math.degrees(math.atan(offset_x / DISTANCE_TO_STAGE))\n    angle_y = math.degrees(math.atan(offset_y / DISTANCE_TO_STAGE))\n\n    # 3. Convert angles to DMX range (0-255)\n    pan_dmx = 128 + (angle_x * (255 / MAX_PAN_ANGLE))\n    tilt_dmx = 128 + (angle_y * (255 / MAX_TILT_ANGLE))\n    return int(pan_dmx), int(tilt_dmx)\n</code></pre>","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#defining-the-main-function","title":"Defining the <code>main</code> Function","text":"<pre><code>def main():\n    while True:\n        try:\n            print(f\"Connecting to stracker.py ({SERVER_IP}:{SERVER_PORT})...\")\n            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            s.connect((SERVER_IP, SERVER_PORT))\n            print(\"&gt;&gt;&gt; Connection established! Waiting for data...\")\n            while True:\n                # Get JSON from stracker.py\n                data_bytes = recv_msg(s)\n                if not data_bytes:\n                    print(\"Server closed connection.\")\n                    break\n\n                # Decode JSON\n                json_str = data_bytes.decode('utf-8')\n                targets = json.loads(json_str)  # List [...]\n\n                # Check for target to follow\n                if len(targets) &gt; 0:\n                    target = targets[0]\n                    x = target.get('CenterX', 0)\n                    y = target.get('CenterY', 0)\n                    state = target.get('State', 0)  # 1 - red (on), 0 - green (off)\n\n                    # --- 1. Movement ---\n                    pan, tilt = calculate_dmx_angles(x, y)\n                    set_dmx_val(CH_PAN, pan)\n                    set_dmx_val(CH_TILT, tilt)\n\n                    # --- 2. Lighting control ---\n                    if state == 1:\n                        set_dmx_val(CH_COLOR, 0)   # White color (0-139)\n                        set_dmx_val(CH_STROBE, 0)  # Strobe open/closed\n                        set_dmx_val(CH_DIMMER, 255)  # Brightness max\n                    else:\n                        set_dmx_val(CH_DIMMER, 0)\n                        set_dmx_val(CH_STROBE, 0)\n\n                s.close()\n        except ConnectionRefusedError:\n            print(\"Cannot connect. Is stracker.py running? Try again in 3 seconds...\")\n            time.sleep(3)\n        except Exception as e:\n            print(f\"Error in loop: {e}\")\n            time.sleep(1)\n</code></pre>","tags":["python","open-dmx","dmx-control"]},{"location":"2026-01-02-python-program-that-controls-an-open-dmx-controller/#conclusion","title":"Conclusion","text":"<p>This solution provides a basic structure for controlling an Enttec OpenDMX controller using Python. The <code>main</code> function continuously listens to the DMX protocol, calculates angles based on camera coordinates, and adjusts lighting settings accordingly.</p> <p>Note that this is just a starting point, and you may need to modify the code to suit your specific requirements or lighting system configuration.</p>","tags":["python","open-dmx","dmx-control"]}]}